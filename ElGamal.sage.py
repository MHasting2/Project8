

# This file was *autogenerated* from the file ElGamal.sage
from sage.all_cmdline import *   # import sage library

_sage_const_2 = Integer(2); _sage_const_1 = Integer(1); _sage_const_256 = Integer(256); _sage_const_20 = Integer(20); _sage_const_0 = Integer(0)
#Pre: size is an exponent, as in 2^size.
#Post: program returns El Gamal parameters, large prime, p and primitive root, a mod p as defined in class and in McAndrew
def param_gen(size):
    p = random_prime(_sage_const_2 **size-_sage_const_1 ,False,_sage_const_2 **(size-_sage_const_1 ))
    a = primitive_root(p)
    return p,a

#Pre: p and a are returned by param_gen
#Post: returns private key, A, and public key, B as defined in class and in McAndrew
def key_gen(p,a):
    A = randint(_sage_const_1 , p-_sage_const_1 )
    B = power_mod(a, A, p)
    return A, B


#Pre: p and a are the returned by parem_gen. A is your private key
#Post: returns r and S as defined in class and in McAndrew
def sign(p, a, A, msg):
    k = p + _sage_const_1 
    #print(k)
    #print(p-1)
    #print(gcd(k,(p-1)))
    #if(k > (p-1)):
     #   print(True)
    #if(gcd(k,(p-1)) != 1):
     #   print(Tru)
    while (k > (p-_sage_const_1 ) and gcd(k,(p-_sage_const_1 )) != _sage_const_1 ):
        k = randint(_sage_const_1 , p-_sage_const_1 )
        
    r = power_mod(a, k, p) 
    ch = txt_to_num(msg)
    S  = inverse_mod(k,p) * (ch - abs(A)*r) % (p-_sage_const_1 )
    return r, S
    

###### Helper Functions ######
    
#Converts a string to a decimal digit sequence
#msg_in is a string
def txt_to_num(msg_in):      
  #transforms string to the indices of each letter in the 8-bit ASCII table
  #ex: "AB" becomes [65,66]
  msg_idx = list(map(ord,msg_in))

  #The integers in the list, since they are ASCII, are in the range 0..255
  #These are treated, collectively, as a base 256 integer, but from left to right
  #rather than right to left
  #This sequence of integers is converted to base 10 
  #ex: [65,66] = 65*256^0 + 66*256^1 = 16961
  num = ZZ(msg_idx,_sage_const_256 )
  return num 

#Converts a digit sequence to a string
#num_in is a decimal integer, constructed from a string using txt_to_num 
def num_to_txt(num_in):
  #transforms the base 10 num_in to a list of base 256 digits. 256^0 is on the left 
  msg_idx = num_in.digits(_sage_const_256 )

  #maps each index to its associated character in the ascii table 
  m = map(chr,msg_idx)

  #transforms the list to a string
  m = ''.join(m)
  return m


def main():
    msg = "Hello World!"
    m = txt_to_num(msg)
    print(m)
    params = param_gen(_sage_const_20 )
    keys = key_gen(params[_sage_const_0 ], params[_sage_const_1 ])
    out = sign(params[_sage_const_0 ], params[_sage_const_1 ], keys[_sage_const_0 ], msg)
    
    print(out[_sage_const_0 ]) #r
    print(out[_sage_const_1 ]) #s
    print(params[_sage_const_0 ]) #p
    print(params[_sage_const_1 ]) #a
    
    a = params[_sage_const_1 ]
    p = params[_sage_const_0 ]
    B = keys[_sage_const_1 ]
    r = out[_sage_const_0 ]
    S = out[_sage_const_1 ]
    
    vOne = power_mod(a,m,p)
    #vTwo = power_mod(B,r,p) * power_mod(r,S,p)
    
    vTwo = ((B**r) * (r**S)) % p
    
    print(vOne == vTwo)

main()

